# 设计模式

[toc]

## 设计模式实例[16]

按照设计模式的目的进行划分，现有的设计模式可以分为创建型、结构型和行为型三种模式。设计模式具有适应需求变化的优点。

- 创建型模式：abstractfactory、builder构造器模式、factorymethod、prototype原型模式、**singleton**等，
- 结构型模式：adaptor适配器模式、bridge桥接模式、composite组合模式、decorator装饰器模式、facade外观模式、flyweight和proxy代理模式，
- 行为型模式：chain      of responsibility责任链、command命令模式、interpreter解释器模式、iterator迭代器模式、mediator中介者模式、**memento备忘录模式**、observer观察者模式、state状态模式、strategy策略模式、template method、visitor访问者模式等。

 

## 创建型模式 

- abstractfactory：
- builder构造器模式：
- factorymethod：
- prototype原型模式：
- singleton：

 

## 结构型模式

- adaptor适配器模式：
- bridge桥接模式：bridge桥接模式可以将一个复杂的组件分成功能性抽象和内部实现两个独立的但又相关的继承层次结构，改变组件的这两个层次结构很简单，以至于它们可以互相独立地变化，采用bridge模式可以将接口与实现分离，提高了可扩展性，并对客户端隐藏了实现的细节。桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- composite组合模式：
- decorator装饰器模式：能够动态地对一个对象进行功能上的扩展，也可以对其子类进行功能上的扩展。
- facade外观模式：外观(facade)模式是对象的结构模式，要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- flyweight：
- proxy代理模式：解决直接访问对象时带来的问题。

例如，要访问的对象在远程的机器上；对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问等。

 

## 行为型模式          

- chain of      responsibility责任链：针对每一个词需要对内容进行**分析与过滤**，而且需要支持敏感词处理的灵活添加。
- interpreter解释器模式：解释器模式属于类的行为模式，描述了如何为语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子，这里的“语言”是使用规定格式和语法的代码。
- strategy策略模式：策略模式是一种对象的行为型模式，定义一系列算法，并将每个算法封装起来，并让它们可以**相互替换**。策略模式让算法独立于使用它的客户而变化，其目的是将行为和环境分隔，当出现新的行为时，只需要实现新的策略类。
- mediator中介者模式：中介者模式是一种对象的行为行模式，通过一个中介对象来封装一系列的对象交互。中介者使得各对象**不需要现实地相互引用**，从而使其**耦合松散**，而且可以**独立地改变它们之间的交互**。中介者对象的存在保证了对象结构上的稳定，也就说说系统的结构不会因为新对象的引入带来大量的修改工作。
- iterator迭代器模式：迭代器模式是一种对象的行为型模式，提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。迭代器模式支持以不同的方式遍历一个聚合对象。
- memento备忘录模式：
- visitor访问者模式：对某个具有固定结构的活动节点需要多种处理能力，且处理能力可扩展，也就是说要求在不改变原来类结构(活动节点)的基础上增加新功能。
- command命令模式：命令模式可以将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，还可以对请求排队，或记录请求日志，以及支持**可撤销**的操作。
- state状态模式：状态模式将每一个条件分支放入一个独立的类中，这样就可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以**不依赖于其他对象**而独立变化

 

## 包装器外观(Wrapper Facade)设计模式[14] 

某公司欲开发一个用于分布式登录的服务端程序，使用面向连接的TCP协议并发地处理多客户端登录请求。用户要求该服务端程序运行在Linux、Solaris和Windows NT等多种操作系统平台之上，而不同的操作系统的相关API函数和数据都有所不同。针对这种情况，公司的架构师决定采用“包装器外观(Wrapper Facade)”架构模式解决操作系统的差异问题。具体来说，服务端程序应该在包装器外观的实例上调用需要的方法，然后将请求和请求的参数发送给**(操作系统API函数)**，调用成功后将结果返回。使用该模式**(提高了底层代码访问的一致性，但降低了服务端程序的调用性能)**。

 

架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。第一项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是**客户机**、**服务器**和**网络**。

 