# 系统开发方法

[toc]

## 软件开发方法

##### 软件开发方法

1. **结构化方法**：用户至上，严格区分工作阶段，系统开发过程工程化。

   缺点：面向过程，比较死板

2. **原型法**：适合需求不明确的开发

3. **面向对象方法**：更好的复用性，关键在于建立一个全面、合理、统一的模型

4. **面向服务的方法**：SO方法有三个主要的抽象级别：操作、服务、业务流程

   SOAD有三个层次：基础设计层、应用结构层、业务组织层

   服务建模：分为服务发现、服务规约、服务实现



##### 软件开发模型[16]

1. **瀑布模型**：瀑布模型是最早使用的软件生存周期模型之一。瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建立在前一个阶段的正确结果之上，前一个阶段的错误和疏漏会隐蔽地带入后一个阶段。这种错误有时甚至可能是灾难性的，因此每一个阶段工作完成后，都要进行审查和确认。适合于需求明确的项目。
2. 演化模型：快速应用开发
3. 增量模型：构建组装模型/给予构建的开发方法
4. **原型模型**：敏捷开发方法。抛弃型原型&演化型原型。
5. **螺旋模型**：在快速模型的基础上扩展而成。螺旋模型将整个软件开发过程分为多个阶段，每个阶段都由目标设定、**风险分析**、开发和有效性验证以及评审4个部分组成。螺旋模型=原型模型+瀑布模型。
6. 喷泉模型：模型驱动的开发方法
7. V模型：基于架构的开发方法。强调测试重要性。
8. 快速应用开发：瀑布模型+给予构件的开发。



##### 逆向工程



##### 净室软件工程

- 净室即无尘室、洁净室，也就是一个受控污染级别的环境。



## 敏捷开发方法[16、14]

​	敏捷方法是从20世纪90年代开始逐渐引起广泛关注的一些新型软件开发方法，以应对快速变化的需求。敏捷方法的核心思想主要有以下三点。

1. 敏捷方法是“适应性”而非“预设性”的。传统方法试图对一个软件开发项目在很长的时间跨度内做出详细的计划，然后依计划进行开发。这类方法在计划制定完成后拒绝变化。而敏捷方法则欢迎变化，其实它的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化。

2. 敏捷方法是以人为本，而不是以过程为本。传统方法以过程为本，强调充分发挥人的特性，不去限制它，并且软件开发在无过程控制和过于严格繁琐的过程控制中取得一种平衡，以保证软件的质量。

3. 迭代增量式的开发过程。敏捷方法以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。

敏捷开发方法有

1. XP极限编程：
2. Cockburn水晶系列方法：
3. 开放式源码：开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广。
4. SCRUM：
5. Coad的功用驱动开发方法FDD：在FDD中，编程开发人员分成**首席程序员**和**“类”程序员(class owner)**两类。
6. ASD：猜测、合作与学习





## 需求工程

##### 需求获取

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。需求可以分为业务需求、用户需求和系统需求。

##### 需求分析



##### UML图



##### UML关系





## 软件系统工具[16]

1. 软件开发工具：
2. 设计工具：
3. 编码与排错工具：
4. **软件维护工具**：如版本控制工具
5. 软件管理和软件支持工具：如版本管理工具和版本评价工具



## 软件重用的基础知识[16]

软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。

软件元素包括程序代码、测试用例、设计文档、设计过程、需求分析文档甚至领域知识。



## 面向构件的编程[16]

基于一般OOP风格，面向构件的编程需要下列基本的支持：**多态性**(可替代性)、**模块封装性**(高层次信息的隐藏)、**后期的绑定和装载**(部署独立性)和**安全性**(类型和模块安全性)。

软件构件是部署、版本控制和替换的基本单位。构件是一组通常需要同时部署的原子构件。原子构件通常成组地部署，但是它也能够被单独部署。构件与原子构件的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。一个模块是不带单独资源的原子构件。

基于构件的开发模型由软件的需求分析定义、**体系结构设计**、**构件库建立**、**应用软件构建**以及测试和发布5个阶段组成。









##### 软件系统建模



##### 系统设计



##### 测试与评审



##### 系统运行与软件维护

